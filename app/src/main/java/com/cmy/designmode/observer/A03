观察者模式
说明:
    Subject（抽象主题）：又叫抽象被观察者，把所有观察者对象的引用保存到一个集合里，
    每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
    ConcreteSubject（具体主题）：又叫具体被观察者，将有关状态存入具体观察者对象；
    在具体主题内部状态改变时，给所有登记过的观察者发出通知。
    Observer (抽象观察者):为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
    ConcrereObserver（具体观察者）：实现抽象观察者定义的更新接口，当得到主题更改通知时更新自身的状态。
    eg.............

    1.应用场景
    当一个对象的改变需要通知其它对象改变时，而且它不知道具体有多少个对象有待改变时。
    当一个对象必须通知其它对象，而它又不能假定其它对象是谁
    跨系统的消息交换场景，如消息队列、事件总线的处理机制。
    2.优点
    解除观察者与主题之间的耦合。让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。
    易于扩展，对同一主题新增观察者时无需修改原有代码。
    3.缺点
    依赖关系并未完全解除，抽象主题仍然依赖抽象观察者。
    使用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，
    而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。
    可能会引起多余的数据通知。




